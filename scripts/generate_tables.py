""" Generate hard-coded compile-time constant tables to speed up compilation
    
    4/12/2020
"""
from datetime import datetime
import os, sys
import getopt

def usage(shortopts, longopts, description):
    """Display usage information

    Args:
        shortopts (:obj:`list` of :obj:`str`): A list of the short-hand form of
            options
        longopts (:obj:`list` of :obj:`str`): A list of the long-hand form of
            options
        description (:obj:`list` of :obj:`str`): A description of each option

    """

    sys.stdout.write("Usage: %s [options]\n" % sys.argv[0])
    sys.stdout.write("Options:\n")
    for i in range(len(shortopts)):
        sys.stdout.write("\t-%s, --%s\n" % (shortopts[i], longopts[i]))
        sys.stdout.write("\t\t%s\n" % description[i])

    sys.stdout.flush();

def BitCount16(word):
    """Count the number of bits set in a word in O(n) time

    Args:
        word (int): A 16-bit word

    Returns:
        A count of the number of bits set to 1 within `word`

    Raises:
        ValueError: If `word` does not fit within 16 bits
    """
    if (word & 0xffff) != word:
        raise(ValueError("Not a 16-bit number: 0x%x" % word))

    count = 0
    while word != 0:
        word = word & (word-1)
        count = count + 1

    return count

def GetLsb16(word):
    """Get the index of the least significant bit set in O(n) time

    Args:
        word (int): A 16-bit word

    Returns:
        Index of the least significant bit (LSB) set, or -1 if `word` is zero

    Raises:
        ValueError: If `word` does not fit within 16 bits
    """
    if (word & 0xffff) != word:
        raise(ValueError("Not a 16-bit number: 0x%x" % word))

    bit  = 0
    mask = 1

    if word != 0:
        while not (mask & word):
            mask <<= 1
            bit = bit + 1
        return bit

    return -1

def GetMsb16(word):
    """Get the index of the most significant bit set in O(n) time

    Args:
        word (int): A 16-bit word

    Returns:
        Index of the most significant bit (MSB) set, or -1 if `word` is zero

    Raises:
        ValueError: If `word` does not fit within 16 bits
    """
    if (word & 0xffff) != word:
        raise(ValueError("Not a 16-bit number: 0x%x" % word))

    bit  = 15
    mask = 1 << bit

    if word != 0:
        while not (mask & word):
            mask >>= 1
            bit = bit - 1
        return bit

    return -1

def run(directory):
    """Generate the LSB, MSB, and POPCNT lookup tables

    Args:
        directory (str): The directory in which to place the output files

    """
    now = datetime.now().strftime("%m/%d/%Y, %H:%M:%S");

    def write_header(fp, typedesc, description):
        fp.write("/*\n")
        fp.write(" * %s\n" % os.path.basename(fp.name).upper())
        fp.write(" *\n")
        fp.write(" * Auto-generated by %s on %s\n" %
                 (os.path.basename(__file__), now))
        fp.write(" */\n\n")
        fp.write("#ifndef INTERNAL_%s_H_\n" % typedesc)
        fp.write("#define INTERNAL_%s_H_\n\n" % typedesc)
        fp.write("#include <array>\n")
        fp.write("#include <cstdint>\n\n")
        fp.write("namespace chess {\n")
        fp.write("namespace data_tables {\n")
        fp.write("namespace internal {\n\n")

    def write_footer(fp, typedesc):
        fp.write("\n\n")
        fp.write("}  // namespace internal\n")
        fp.write("}  // namespace data_tables\n")
        fp.write("}  // namespace chess\n")
        fp.write("\n#endif  // INTERNAL_%s_H_\n" % typedesc)

    base_path = directory + os.path.sep

    with open(base_path + "lsb.h", 'w') as fp:
        write_header(fp, "LSB", "16-bit LSB lookup table")
        fp.write("constexpr std::array<std::int8_t,65536> lsb = {");
        for i in range(65536):
            if i % 8 == 0:
                fp.write("\n\t");
            fp.write("%2s" % str(GetLsb16(i)))
            if i < 65535:
                fp.write(", ")

        fp.write("\n};")
        write_footer(fp, "LSB");

    with open(base_path + "msb.h", 'w') as fp:
        write_header(fp, "MSB", "16-bit MSB lookup table")
        fp.write("constexpr std::array<std::int8_t,65536> msb = {");
        for i in range(65536):
            if i % 8 == 0:
                fp.write("\n\t");
            fp.write("%2s" % str(GetMsb16(i)))
            if i < 65535:
                fp.write(", ")

        fp.write("\n};")
        write_footer(fp, "MSB");

    with open(base_path + "popcnt.h", 'w') as fp:
        write_header(fp, "POPCNT", "16-bit POPCNT lookup table")
        fp.write("constexpr std::array<std::int8_t,65536> pop = {");
        for i in range(65536):
            if i % 8 == 0:
                fp.write("\n\t");
            fp.write("%2s" % str(BitCount16(i)))
            if i < 65535:
                fp.write(", ")

        fp.write("\n};")
        write_footer(fp, "POPCNT");


def main():
    """Entry point

    """
    shortopts   = "hd:"
    longopts    = ["help", "directory="]
    description = ["Print this help message",
                   "Output directory for generated files"]

    def show_usage():
        temp_longopts = []
        for opt in longopts:
            temp_longopts.append(opt.replace('=', ''))

        usage(shortopts.replace(':', ''), temp_longopts, description)

    directory = "";

    try:
        opts, args = getopt.getopt(sys.argv[1:], shortopts, longopts)
        for o, a in opts:
            if o in ("-h", "--help"):
                show_usage()
                return
            elif o in ("-d", "--directory"):
                directory = a
            else:
                assert False, "unhandled option"

    except getopt.GetoptError as err:
        print(str(err))
        show_usage();
        sys.exit(-1)

    if len(directory) == 0:
        sys.stdout.write("Output directory required. Try --help for usage.\n")
        sys.stdout.flush()
        sys.exit(-1)

    if not os.path.isdir(directory):
        sys.stdout.write("Not a directory: %s\n" % directory)
        sys.stdout.flush()
        sys.exit(-1)

    sys.stdout.write("%s: Files will be written to %s\n" %
                     (os.path.basename(__file__), directory))
    sys.stdout.flush()

    run(directory)


if __name__ == "__main__":
    main()
